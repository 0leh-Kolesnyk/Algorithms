// Алгоритм Дейкстра

const graph = {}
graph.a = {b: 2, c: 1} // каждой вершине графа соответствует объект,
graph.b = {f: 7}       // с указанием вершин в которую можно попасть и расстоянием до нее
graph.c = {d: 5, e: 2} //
graph.d = {f: 2}
graph.e = {f: 1}
graph.f = {g: 1}
graph.g = {}

function shortPath(graph, start, end) {//создаем функцию, параметры: объект, начальная и конечная точки
    const costs = {}//создали объект - табличка, в которой будем хранить минимальные стоимости всех ребер
    const processed = []//массив, который будет хранить обработанные объекты
    let neighbors = {}//объект для хранения ближайших соседних вершин рассматриваемого узла
    Object.keys(graph).forEach(node => { //Object.keys(graph) - преобразует объект в массив,
        if (node !== start) {
            let value = graph[start][node] // в цикл добавили значения до тех вершин, в которые мы можем попасть со стартовой
            costs[node] = value || 100000000 // т.е. получаем значения от а до остальных точек
            // и значения расстояний до них если есть, а если пути нет - то большое число - 100000000
        }
    })

    let node = findNodeLowestCost(costs, processed)//находим узел с мин стоимостью пути
    while (node) { // в цикле последовательно перебирая узлы с минимальными стоимостями
        const cost = costs[node] //на каждой итерации мы получаем стоимость текущей вершины
        neighbors = graph[node] //и те узлы в которые мы можем попасть из этой вершины мы присваиваем в тот объект,
        // который мы создавали для соседних вершин, для того, чтобы мы могли по ним проитеррироваться
        Object.keys(neighbors).forEach(neighbor => {//получаем ключи у этого объекта и с помощью цикла .forEach
            // итеррируемся по массиву, который вернет нам эта функция
            let newCost = cost + neighbors[neighbor]//перезаписываем новые полученные значения стоимости путти
            if (newCost < costs[neighbor]) {
                costs[neighbor] = newCost // обновляли значение в табл, где храним мин стоимость пути
            }
        })
        processed.push(node)//в конце цикла каждый узел помечали как обработанный
        node = findNodeLowestCost(costs, processed) // ищем новую вершину
    }
    return costs // вернем объект с кратчайшими путями
}

//ищем вершину в которую можем попасть из точки а и путь в которую самый короткий:
function findNodeLowestCost(costs, processed) {
    let lowestCost = 100000000 // минимальное значение пути (по умолч большое число)
    let lowestNode; // узел, который будем возвращать с мин. значением
    Object.keys(costs).forEach(node => {//проводим итерацию по ключам объектов в которых мы храним стоимость путей
        let cost = costs[node]//получаем стоимость пути по ключу из объекта costs
        if (cost < lowestCost && !processed.includes(node)) {
            //если стоимость, которую мы получили < чем мин стоимость, и вершина не находится в массиве обработанных вершин,
            // то мы нашли новый объект у которого путь короче и обновляем переменные
            lowestCost = cost
            lowestNode = node
        }
    })
    return lowestNode //возвращаем вершину с мин стоимостью пути
}

console.log(shortPath(graph, 'a', 'g'))
// { b: 2, c: 1, d: 6, e: 3, f: 4, g: 5 } получили объект,
// который хранит кратчайшие пути от точки "а" до финальной точки